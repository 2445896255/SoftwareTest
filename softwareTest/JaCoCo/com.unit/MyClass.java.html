<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MyClass.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">softwareTest$TestMyClass.exec</a> &gt; <a href="index.source.html" class="el_package">com.unit</a> &gt; <span class="el_source">MyClass.java</span></div><h1>MyClass.java</h1><pre class="source lang-java linenums">package com.unit;

<span class="fc" id="L3">public class MyClass {</span>


    /**
     * 求两个数的最大公约数
     * @param num1
     * @param num2
     * @return
     */
    public int getGCD(int num1, int num2) {
<span class="fc" id="L13">        num1 = Math.abs(num1);</span>
<span class="fc" id="L14">        num2 = Math.abs(num2);</span>
<span class="fc bfc" id="L15" title="All 2 branches covered.">        while (num2 != 0) {</span>
<span class="fc" id="L16">            int remainder = num1 % num2;</span>
<span class="fc" id="L17">            num1 = num2;</span>
<span class="fc" id="L18">            num2 = remainder;</span>
<span class="fc" id="L19">        }</span>
<span class="fc" id="L20">        return num1;</span>
    }

    /**
     * 求两个数的最小公倍数
     * @param num1
     * @param num2
     * @return
     */
    public int lcm(int num1, int num2){
<span class="fc" id="L30">        int p1 = num1;</span>
<span class="fc" id="L31">        int q1 = num2;</span>

<span class="fc bfc" id="L33" title="All 2 branches covered.">        while(num2 != 0){</span>
<span class="fc" id="L34">            int r = num1 % num2;</span>
<span class="fc" id="L35">            num1 = num2;</span>
<span class="fc" id="L36">            num2 = r;</span>
<span class="fc" id="L37">        }</span>
<span class="fc" id="L38">        return (p1*q1)/num1;</span>
    }

    /**
     * 判断一个大于2的数是不是质数
     * @param n
     * @return
     */
    public boolean isPrimeNum(int n) {
<span class="fc bfc" id="L47" title="All 2 branches covered.">        for (int i = 2; i &lt; n; i++) {</span>
<span class="fc bfc" id="L48" title="All 2 branches covered.">            if (n%i==0) {</span>
<span class="fc" id="L49">                return false;</span>
            }
        }
<span class="fc" id="L52">        return true;</span>
    }

    /**
     * 判断是否闰年
     * @param year
     * @return
     */
    public boolean isLeapYear(int year){
<span class="pc bpc" id="L61" title="1 of 6 branches missed.">        if(year % 4== 0 &amp;&amp; year%100!=0||year%400==0)</span>
        {
<span class="fc" id="L63">            return true;</span>
        }
<span class="fc" id="L65">        return false;</span>
    }

    /**
     * 判断father是否包含child
     * @param father
     * @param child
     * @return
     */
    public boolean containsString(String father,String child){
<span class="fc bfc" id="L75" title="All 2 branches covered.">        if(father.indexOf(child)==-1)</span>
<span class="fc" id="L76">            return false;</span>
<span class="fc" id="L77">        return true;</span>
    }

    /**
     * 判断字符串是否回文
     * @param A
     * @return
     */
    public boolean IsPalindrome1(String A){
<span class="fc" id="L86">        char[] arrayA = A.toCharArray();</span>
<span class="fc" id="L87">        int top = 0;</span>
<span class="fc" id="L88">        int end = arrayA.length-1;</span>
<span class="pc bpc" id="L89" title="2 of 4 branches missed.">        if(A.equals(&quot;&quot;) || A.equals(null))</span>
<span class="nc" id="L90">            return false;</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">        while(top &lt; end){</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">            if(arrayA[top++] != arrayA[end--])</span>
<span class="fc" id="L93">                return false;</span>
        }
<span class="fc" id="L95">        return true;</span>
    }

    /**
     * 计算一个字符串的倒序
     * @param str
     * @return
     */
    public String reverseString(String str){
<span class="fc" id="L104">        char[] ch = str.toCharArray();</span>
<span class="fc" id="L105">        StringBuffer sb = new StringBuffer();</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">        for (int i = ch.length - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L107">            sb.append(ch[i]);</span>
        }
<span class="fc" id="L109">        return sb.toString();</span>
    }

    /**
     * 自除数 是指可以被它包含的每一位数除尽的数。
     * 自除数不允许包含 0 。
     * @param n
     * @return
     */
    public boolean selfDividing(int n) {
<span class="fc bfc" id="L119" title="All 2 branches covered.">        for (char c: String.valueOf(n).toCharArray()) {</span>
<span class="pc bpc" id="L120" title="1 of 4 branches missed.">            if (c == '0' || (n % (c - '0') &gt; 0))</span>
<span class="fc" id="L121">                return false;</span>
        }
<span class="fc" id="L123">        return true;</span>
    }

    /**
     * 斐波那契数
     * @param N
     * @return
     */
    public int fib(int N) {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (N &lt;= 1) {</span>
<span class="fc" id="L133">            return N;</span>
        }
<span class="fc" id="L135">        return fib(N-1) + fib(N-2);</span>
    }

    /**
     * 判断一个数 n 是不是快乐数。
     * 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。
     * 如果 n 是快乐数就返回 True ；不是，则返回 False 。
     * @param n
     * @return
     */
    public boolean isHappy(int n) {
<span class="fc" id="L146">        int slowRunner = n;</span>
<span class="fc" id="L147">        int fastRunner = getNext(n);</span>
<span class="fc bfc" id="L148" title="All 4 branches covered.">        while (fastRunner != 1 &amp;&amp; slowRunner != fastRunner) {</span>
<span class="fc" id="L149">            slowRunner = getNext(slowRunner);</span>
<span class="fc" id="L150">            fastRunner = getNext(getNext(fastRunner));</span>
        }
<span class="fc bfc" id="L152" title="All 2 branches covered.">        return fastRunner == 1;</span>
    }

    public int getNext(int n) {
<span class="fc" id="L156">        int totalSum = 0;</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        while (n &gt; 0) {</span>
<span class="fc" id="L158">            int d = n % 10;</span>
<span class="fc" id="L159">            n = n / 10;</span>
<span class="fc" id="L160">            totalSum += d * d;</span>
<span class="fc" id="L161">        }</span>
<span class="fc" id="L162">        return totalSum;</span>
    }

    /**
     * 二进制求和
     * @param a
     * @param b
     * @return
     */
    public String addBinary(String a, String b) {
<span class="fc" id="L172">        return Integer.toBinaryString(Integer.parseInt(a, 2) + Integer.parseInt(b, 2));</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>